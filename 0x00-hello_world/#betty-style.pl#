#!/usr/bin/perl -w
# (c) 2001, Dave Jones. (the file handling bit)
# (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)
# (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)
# (c) 2008-2010 Andy Whitcroft <apw@canonical.com>
# Licensed under the terms of the GNU GPL License version 2

use strict;
use POSIX;
use File::Basename;
use Cwd 'abs_path';
use Term::ANSIColor qw(:constants);

my $P = $0;
my $D = dirname(abs_path($P));

my $V = '0.32';

use Getopt::Long qw(:config no_auto_abbrev);

my $quiet = 0;
my $tree = 1;
my $chk_signoff = 1;
my $chk_patch = 1;
my $tst_only;
my $emacs = 0;
my $terse = 0;
my $showfile = 0;
my $file = 0;
my $git = 0;
my %git_commits = ();
my $check = 0;
my $check_orig = 0;
my $summary = 1;
my $mailback = 0;
my $summary_file = 0;
my $show_types = 0;
my $list_types = 0;
my $fix = 0;
my $fix_inplace = 0;
my $root;
my %debug;
my %camelcase = ();
my %use_type = ();
my @use = ();
my %ignore_type = ();
my @ignore = ();
my $help = 0;
my $printVersion = 0;
my $configuration_file = ".checkpatch.conf";
my $max_line_length = 80;
my $max_func_length = 40;
my $max_funcs = 5;
my $ignore_perl_version = 0;
my $minimum_perl_version = 5.10.0;
my $min_conf_desc_length = 4;
my $spelling_file = "$D/spelling.txt";
my $codespell = 0;
my $codespellfile = "/usr/share/codespell/dictionary.txt";
my $color = 1;

sub printVersion {
    my ($exitcode) = @_;

    print << "EOM";
    Version: $V
EOM
exit($exitcode);
}

sub help {
    my ($exitcode) = @_;

    print << "EOM";
    Usage: $P [OPTION]... [FILE]...
	Version: $V
	Options:
  -q, --quiet                quiet
  --no-tree                  run without a kernel tree. Active by default
  --no-signoff               do not check for 'Signed-off-by' line
  --patch                    treat FILE as patchfile (default)
  --emacs                    emacs compile window format
  --terse                    one line per report. Active by default
  --showfile                 emit diffed file position, not input file position
  -g, --git                  treat FILE as a single commit or git revision range
                             single git commit with:
                               <rev>
                               <rev>^
                               <rev>~n
                             multiple git commits with:
                               <rev1>..<rev2>
                               <rev1>...<rev2>
                               <rev>-<count>
                             git merges are ignored
  -f, --file                 treat FILE as regular source file. Active by default
  --subjective, --strict     enable more subjective tests
  --list-types               list the possible message types
  --types TYPE(,TYPE2...)    show only these comma separated message types
  --ignore TYPE(,TYPE2...)   ignore various comma separated message types
  --show-types               show the specific message type in the output
  --max-line-length=n        set the maximum line length, if exceeded, warn
  --min-conf-desc-length=n   set the min description length, if shorter, warn
  --root=PATH                PATH to the kernel tree root
  --no-summary               suppress the per-file summary
  --mailback                 only produce a report in case of warnings/errors
  --summary-file             include the filename in summary
  --debug KEY=[0|1]          turn on/off debugging of KEY, where KEY is one of
                             'values', 'possible', 'type', and 'attr' (default
                             is all off)
  --test-only=WORD           report only warnings/errors containing WORD
                             literally
  --fix                      EXPERIMENTAL - may create horrible results
                             If correctable single-line errors exist, create
                             "<inputfile>.EXPERIMENTAL-checkpatch-fixes"
                             with potential errors corrected to the preferred
                             checkpatch style
  --fix-inplace              EXPERIMENTAL - may create horrible results
                             Is the same as --fix, but overwrites the input
                             file.  It's your fault if there's no backup or git
  --ignore-perl-version      override checking of perl version.  expect
                             runtime errors.
  --codespell                Use the codespell dictionary for spelling/typos
                             (default:/usr/share/codespell/dictionary.txt)
  --codespellfile            Use this codespell dictionary
  --color                    Use colors when output is STDOUT (default: on)
  -h, --help, --version      display this help and exit
When FILE is - read standard input.
EOM

exit($exitcode);
}

sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
}

sub list_types {
    my ($exitcode) = @_;

    my $count = 0;

    local $/ = undef;

    open(my $script, '<', abs_path($P)) or
	die "$P: Can't read '$P' $!\n";

    my $text = <$script>;
    close($script);

    my @types = ();
    for ($text =~ /\b(?:(?:CHK|WARN|ERROR)\s*\(\s*"([^"]+)")/g) {
push (@types, $_);
}
    @types = sort(uniq(@types));
    print("#\tMessage type\n\n");
    foreach my $type (@types) {
	print(++$count . "\t" . $type . "\n");
    }

    exit($exitcode);
}

my $conf = which_conf($configuration_file);
if (-f $conf) {
    my @conf_args;
    open(my $conffile, '<', "$conf")
	or warn "$P: Can't find a readable $configuration_file file $!\n";

    while (<$conffile>) {
	my $line = $_;

	$line =~ s/\s*\n?$//g;
	$line =~ s/^\s*//g;
	$line =~ s/\s+/ /g;

	next if ($line =~ m/^\s*#/);
	next if ($line =~ m/^\s*$/);

	my @words = split(" ", $line);
	foreach my $word (@words) {
	    last if ($word =~ m/^#/);
		     push (@conf_args, $word);
		}
	}
	close($conffile);
	unshift(@ARGV, @conf_args) if @conf_args;
    }

GetOptions(
    'q|quiet+'=> \$quiet,
    'tree!'=> \$tree,
    'signoff!'=> \$chk_signoff,
    'patch!'=> \$chk_patch,
    'emacs!'=> \$emacs,
    'terse!'=> \$terse,
    'showfile!'=> \$showfile,
    'f|file!'=> \$file,
    'g|git!'=> \$git,
    'subjective!'=> \$check,
    'strict!'=> \$check,
    'ignore=s'=> \@ignore,
    'types=s'=> \@use,
    'show-types!'=> \$show_types,
    'list-types!'=> \$list_types,
    'max-line-length=i' => \$max_line_length,
    'max-func-length=i' => \$max_func_length,
    'max-funcs=i' => \$max_funcs,
    'min-conf-desc-length=i' => \$min_conf_desc_length,
    'root=s'=> \$root,
    'summary!'=> \$summary,
    'mailback!'=> \$mailback,
    'summary-file!'=> \$summary_file,
    'fix!'=> \$fix,
    'fix-inplace!'=> \$fix_inplace,
    'ignore-perl-version!' => \$ignore_perl_version,
    'debug=s'=> \%debug,
    'test-only=s'=> \$tst_only,
    'codespell!'=> \$codespell,
    'codespellfile=s'=> \$codespellfile,
    'color!'=> \$color,
    'h|help'=> \$help,
    'version'=> \$printVersion
    ) or help(1);

#Force --no-tree
$tree = 0;
#Force --terse
$terse = 1;
#Force -f
$file = 1;

help(0) if ($help);

printVersion(0) if ($printVersion);

list_types(0) if ($list_types);

$fix = 1 if ($fix_inplace);
$check_orig = $check;

my $exit = 0;

if ($^V && $^V lt $minimum_perl_version) {
    printf "$P: requires at least perl version %vd\n", $minimum_perl_version;
    if (!$ignore_perl_version) {
	exit(1);
    }
}

if ($#ARGV < 0) {
    print "$P: no input files\n";
    exit(1);
}

sub hash_save_array_words {
    my ($hashRef, $arrayRef) = @_;

    my @array = split(/,/, join(',', @$arrayRef));
    foreach my $word (@array) {
	$word =~ s/\s*\n?$//g;
	$word =~ s/^\s*//g;
	$word =~ s/\s+/ /g;
	$word =~ tr/[a-z]/[A-Z]/;

	next if ($word =~ m/^\s*#/);
	next if ($word =~ m/^\s*$/);

	$hashRef->{$word}++;
    }
}

sub hash_show_words {
    my ($hashRef, $prefix) = @_;

    if (keys %$hashRef) {
	print "\nNOTE: $prefix message types:";
	foreach my $word (sort keys %$hashRef) {
	    print " $word";
	}
	print "\n";
    }
}

hash_save_array_words(\%ignore_type, \@ignore);
hash_save_array_words(\%use_type, \@use);

my $dbg_values = 0;
my $dbg_possible = 0;
my $dbg_type = 0;
my $dbg_attr = 0;
for my $key (keys %debug) {
    ## no critic
    eval "\${dbg_$key} = '$debug{$key}';";
    die "$@" if ($@);
}

my $rpt_cleaners = 0;

if ($terse) {
    $emacs = 1;
    $quiet++;
}

if ($tree) {
    if (defined $root) {
	if (!top_of_kernel_tree($root)) {
	    die "$P: $root: --root does not point at a valid tree\n";
	}
    } else {
	if (top_of_kernel_tree('.')) {
	    $root = '.';
	} elsif ($0 =~ m@(.*)/scripts/[^/]*$@ &&
		 top_of_kernel_tree($1)) {
	    $root = $1;
	}
    }

    if (!defined $root) {
	print "Must be run from the top-level dir. of a kernel tree\n";
	exit(2);
    }
}

my $emitted_corrupt = 0;

our $Ident= qr{
    [A-Za-z_][A-Za-z\d_]*
(?:\s*\#\#\s*[A-Za-z_][A-Za-z\d_]*)*
    
# We need \b after 'init' otherwise 'initconst' will cause a false positive in a check
    our $Attribute= qr{
const|
__percpu|
__nocast|
__safe|
__bitwise__|
__packed__|
__packed2__|
__naked|
__maybe_unused|
__always_unused|
__noreturn|
__used|
__cold|
__pure|
__noclone|
__deprecated|
__read_mostly|
__kprobes|
$InitAttribute|
____cacheline_aligned|
____cacheline_aligned_in_smp|
____cacheline_internodealigned_in_smp|
__weak
  }x;
our $Modifier;
our $Inline= qr{inline|__always_inline|noinline|__inline|__inline__};
our $Member= qr{->$Ident|\.$Ident|\[[^]]*\]};
our $Lval= qr{$Ident(?:$Member)*};

our $Int_type= qr{(?i)llu|ull|ll|lu|ul|l|u};
our $Binary= qr{(?i)0b[01]+$Int_type?};
our $Hex= qr{(?i)0x[0-9a-f]+$Int_type?};
our $Int= qr{[0-9]+$Int_type?};
our $Octal= qr{0[0-7]+$Int_type?};
our $String= qr{"[X\t]*"};
our $Float_hex= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};
our $Float_dec= qr{(?i)(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)(?:e-?[0-9]+)?[fl]?};
our $Float_int= qr{(?i)[0-9]+e-?[0-9]+[fl]?};
our $Float= qr{$Float_hex|$Float_dec|$Float_int};
our $Constant= qr{$Float|$Binary|$Octal|$Hex|$Int};
our $Assignment= qr{\*\=|/=|%=|\+=|-=|<<=|>>=|&=|\^=|\|=|=};
our $Compare    = qr{<=|>=|==|!=|<|(?<!-)>};
our $Arithmetic = qr{\+|-|\*|\/|%};
our $Operators= qr{
<=|>=|==|!=|
=>|->|<<|>>|<|>|!|~|
&&|\|\||,|\^|\+\+|--|&|\||$Arithmetic
  }x;

our $c90_Keywords = qr{do|for|while|if|else|return|goto|continue|switch|default|case|break}x;

our $BasicType;
our $NonptrType;
our $NonptrTypeMisordered;
our $NonptrTypeWithAttr;
our $Type;
our $TypeMisordered;
our $Declare;
our $DeclareMisordered;

our $NON_ASCII_UTF8= qr{
[\xC2-\xDF][\x80-\xBF]               # non-overlong 2-byte
es 4-15
 @typeListMisordered = (
}_t},
4|size_t|atomic_t|bool|blob|regset32|u32_array)", 2],
["proc_create(?:_data|)", 2],
l be found - file '$spelling_file': $!\n";
}

if ($codespell) {
if (open(my $spelling, '<', $codespellfile)) {
while (<$spelling>) {
my $line = $_;

$line =~ s/\s*\n?$//g;
$line =~ s/^\s*//g;

next if ($line =~ m/^\s*#/);
next if ($line =~ m/^\s*$/);
next if ($line =~ m/, disabled/i);

$line =~ s/,.*$//;

my ($suspect, $fix) = split(/->/, $line);

$spelling_fix{$suspect} = $fix;
}
close($spelling);
} else {
warn "No codespell typos will be found - file '$codespellfile': $!\n";
}
}

$misspellings = join("|", sort keys %spelling_fix) if keys %spelling_fix;

sub build_types {
:${all}\b)
ptrType\s*\)){0,1}\s*};

# Using $balanced_parens, $LvalOrFunc, or $FuncArg
# requires at least perl version v5.10.0
# Any use must be runtime checked with $^V

our $balanced_parens = qr/(\((?:[^\(\)]++|(?-1))*\))/;
our $LvalOrFunc= qr{((?:[\&\*]\s*)?$Lval)\s*($balanced_parens{0,1})\s*};
our $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};

our $declaration_macros = qr{(?x:
(?:$Storage\s+)?(?:[A-Z_][A-Z0-9]*_){0,2}(?:DEFINE|DECLARE)(?:_[A-Z0-9]+){1,6}\s*\(|
(?:$Storage\s+)?LIST_HEAD\s*\(|
(?:$Storage\s+)?${Type}\s+uninitialized_var\s*\(
)};

sub deparenthesize {
my ($string) = @_;
('\n', $text);

OSIX::strftime("%Y%m%d%H%M",
       localtime((stat $file)[9]));
sc) if ((which("git") eq "") || !(-e ".git"));

the commit expressions.
# For example, HEAD-3 means we need check 'HEAD, HEAD~1, HEAD~2'.
die "$P: No git repository found\n" if ($git && !-e ".git");

if ($git) {
my @commits = ();
foreach my $commit_expr (@ARGV) {
my $git_range;
if ($commit_expr =~ m/^(.*)-(\d+)$/) {
$git_range = "-$2 $1";
} elsif ($commit_expr =~ m/\.\./) {
$git_range = "$commit_expr";
} else {
$git_range = "-1 $commit_expr";
}
my $lines = `git log --no-color --no-merges --pretty=format:'%H %s' $git_range`;
foreach my $line (split(/\n/, $lines)) {
$line =~ /^([0-9a-fA-F]{40,40}) (.*)$/;
next if (!defined($1) || !defined($2));
my $sha1 = $1;
my $subject = $2;
unshift(@commits, $sha1);
$git_commits{$sha1} = $subject;
}
}
die "$P: no git commits after extraction!\n" if (@commits == 0);
@ARGV = @commits;
}

my $vname;
for my $filename (@ARGV) {
my $FILE;
if ($git) {
open($FILE, '-|', "git format-patch -M --stdout -1 $filename") ||
die "$P: $filename: git format-patch failed - $!\n";
} elsif ($file) {
open($FILE, '-|', "diff -u /dev/null $filename") ||
die "$P: $filename: diff failed - $!\n";
} elsif ($filename eq '-') {
open($FILE, '<&STDIN');
} else {
open($FILE, '<', "$filename") ||
die "$P: $filename: open failed - $!\n";
}
if ($filename eq '-') {
$vname = 'Your patch';
} elsif ($git) {
$vname = "Commit " . substr($filename, 0, 12) . ' ("' . $git_commits{$filename} . '")';
} else {
$vname = $filename;
}
while (<$FILE>) {
chomp;
push(@rawlines, $_);
}
close($FILE);

if ($#ARGV > 0 && $quiet == 0) {
print '-' x length($vname) . "\n";
print "$vname\n";
print '-' x length($vname) . "\n";
}

if (!process($filename)) {
$exit = 1;
}
@rawlines = ();
@lines = ();
@fixed = ();
@fixed_inserted = ();
@fixed_deleted = ();
$fixlinenr = -1;
@modifierListFile = ();
@typeListFile = ();
build_types();
}

if (!$quiet) {
hash_show_words(\%use_type, "Used");
hash_show_words(\%ignore_type, "Ignored");

if ($^V lt 5.10.0) {
print << "EOM"
NOTE: perl $^V is not modern enough to detect all possible issues.
      An upgrade to at least perl v5.10.0 is suggested.
EOM
}
if ($exit) {
print << "EOM"
NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
EOM
}
}

exit($exit);

sub top_of_kernel_tree {
my ($root) = @_;

my @tree_check = (
    "COPYING", "CREDITS", "Kbuild", "MAINTAINERS", "Makefile",
    "README", "Documentation", "arch", "include", "drivers",
    "fs", "init", "ipc", "kernel", "lib", "scripts",
    );

foreach my $check (@tree_check) {
if (! -e $root . '/' . $check) {
return 0;
}
}
return 1;
}

sub parse_email {
my ($formatted_email) = @_;

my $name = "";
my $address = "";
my $comment = "";

if ($formatted_email =~ /^(.*)<(\S+\@\S+)>(.*)$/) {
$name = $1;
$address = $2;
$comment = $3 if defined $3;
} elsif ($formatted_email =~ /^\s*<(\S+\@\S+)>(.*)$/) {
$address = $1;
$comment = $2 if defined $2;
} elsif ($formatted_email =~ /(\S+\@\S+)(.*)$/) {
$address = $1;
$comment = $2 if defined $2;
$formatted_email =~ s/$address.*$//;
$name = $formatted_email;
$name = trim($name);
$name =~ s/^\"|\"$//g;
# If there's a name left after stripping spaces and
# leading quotes, and the address doesn't have both
# leading and trailing angle brackets, the address
# is invalid. ie:
#   "joe smith joe@smith.com" bad
#   "joe smith <joe@smith.com" bad
if ($name ne "" && $address !~ /^<[^>]+>$/) {
$name = "";
$address = "";
$comment = "";
}
}

$name = trim($name);
$name =~ s/^\"|\"$//g;
$address = trim($address);
$address =~ s/^\<|\>$//g;

if ($name =~ /[^\w \-]/i) { ##has "must quote" chars
$name =~ s/(?<!\\)"/\\"/g; ##escape quotes
$name = "\"$name\"";
}

return ($name, $address, $comment);
}

sub format_email {
quotes
$name = "\"$name\"";
}

turn (length($line), length($white));
}

sub real_length {
my ($line) = @_;

return (length($line));
}

my $sanitise_quote = '';

sub sanitise_line_reset {
my ($in_comment) = @_;

if ($in_comment) {
$sanitise_quote = '*/';
} else {
$sanitise_quote = '';
}
}
sub sanitise_line {
my ($line) = @_;

my $res = '';
my $l = '';

my $qlen = 0;
my $off = 0;
my $c;

# Always copy over the diff marker.
$res = substr($line, 0, 1);

for ($off = 1; $off < length($line); $off++) {
$c = substr($line, $off, 1);

# Comments we are wacking completly including the begin
# and end, all to $;.
if ($sanitise_quote eq '' && substr($line, $off, 2) eq '/*') {
$sanitise_quote = '*/';

substr($res, $off, 2, "$;$;");
$off++;
next;
}
if ($sanitise_quote eq '*/' && substr($line, $off, 2) eq '*/') {
$sanitise_quote = '';
substr($res, $off, 2, "$;$;");
$off++;
next;
}
if ($sanitise_quote eq '' && substr($line, $off, 2) eq '//') {
$sanitise_quote = '//';

substr($res, $off, 2, $sanitise_quote);
$off++;
next;
}

# A \ in a string means ignore the next character.
if (($sanitise_quote eq "'" || $sanitise_quote eq '"') &&
        $c eq "\\") {
substr($res, $off, 2, 'XX');
$off++;
next;
}
# Regular quotes.
if ($c eq "'" || $c eq '"') {
if ($sanitise_quote eq '') {
$sanitise_quote = $c;

substr($res, $off, 1, $c);
next;
} elsif ($sanitise_quote eq $c) {
$sanitise_quote = '';
}
}

#print "c<$c> SQ<$sanitise_quote>\n";
if ($off != 0 && $sanitise_quote eq '*/' && $c ne "\t") {
substr($res, $off, 1, $;);
} elsif ($off != 0 && $sanitise_quote eq '//' && $c ne "\t") {
substr($res, $off, 1, $;);
} elsif ($off != 0 && $sanitise_quote && $c ne "\t") {
substr($res, $off, 1, 'X');
} else {
substr($res, $off, 1, $c);
}
}

if ($sanitise_quote eq '//') {
$sanitise_quote = '';
}

# The pathname on a #include may be surrounded by '<' and '>'.
if ($res =~ /^.\s*\#\s*include\s+\<(.*)\>/) {
my $clean = 'X' x length($1);
$res =~ s@\<.*\>@<$clean>@;

# The whole of a #error is a string.
} elsif ($res =~ /^.\s*\#\s*(?:error|warning)\s+(.*)\b/) {
my $clean = 'X' x length($1);
$res =~ s@(\#\s*(?:error|warning)\s+).*@$1$clean@;
}

return $res;
}

sub get_quoted_string {
en = length($blk);
$line++;
last;
}
$remainder =~ /^(else)(?:\s|{)/ &&
$remainder !~ /^else\s+if\b/) {
$coff = $off + length($1) - 1;
$coff_set = 1;
#warn "CSB: mark coff<$coff> soff<$soff> 1<$1>\n";
#warn "[" . substr($blk, $soff, $coff - $soff + 1) . "]\n";
}

fle to the next line.
nes + 2;
 push\n";
push(@chunks, [ $condition, $statement ]);
}

return ($level, $linenr, @chunks);
}

sub ctx_block_get {
@res, $rawlines[$line]);
re out if there is a
($vet) = @_;
\n" if ($dbg_values > 1);
push(@av_paren_type, $type);
$type = 'c';

} elsif ($cur =~ /^($Type)\s*(?:$Ident|,|\)|\(|\s*$)/) {
print "DECLARE($1)\n" if ($dbg_values > 1);
$type = 'T';

} elsif ($cur =~ /^($Modifier)\s*/) {
print "MODIFIER($1)\n" if ($dbg_values > 1);
$type = 'T';

} elsif ($cur =~ /^(\#\s*define\s*$Ident)(\(?)/o) {
print "DEFINE($1,$2)\n" if ($dbg_values > 1);
$av_preprocessor = 1;
push(@av_paren_type, $type);
if ($2 ne '') {
$av_pending = 'N';
}
$type = 'E';

} elsif ($cur =~ /^(\#\s*(?:undef\s*$Ident|include\b))/o) {
print "UNDEF($1)\n" if ($dbg_values > 1);
$av_preprocessor = 1;
push(@av_paren_type, $type);

} elsif ($cur =~ /^(\#\s*(?:ifdef|ifndef|if))/o) {
print "PRE_START($1)\n" if ($dbg_values > 1);
$av_preprocessor = 1;

push(@av_paren_type, $type);
push(@av_paren_type, $type);
$type = 'E';

} elsif ($cur =~ /^(\#\s*(?:else|elif))/o) {
print "PRE_RESTART($1)\n" if ($dbg_values > 1);
$av_preprocessor = 1;

push(@av_paren_type, $av_paren_type[$#av_paren_type]);

$type = 'E';

} elsif ($cur =~ /^(\#\s*(?:endif))/o) {
print "PRE_END($1)\n" if ($dbg_values > 1);

$av_preprocessor = 1;

# Assume all arms of the conditional end as this
# one does, and continue as if the #endif was not here.
pop(@av_paren_type);
push(@av_paren_type, $type);
$type = 'E';

} elsif ($cur =~ /^(\\\n)/o) {
print "PRECONT($1)\n" if ($dbg_values > 1);

} elsif ($cur =~ /^(__attribute__)\s*\(?/o) {
print "ATTR($1)\n" if ($dbg_values > 1);
$av_pending = $type;
$type = 'N';

} elsif ($cur =~ /^(sizeof)\s*(\()?/o) {
print "SIZEOF($1)\n" if ($dbg_values > 1);
if (defined $2) {
$av_pending = 'V';
}
$type = 'N';

} elsif ($cur =~ /^(if|while|for)\b/o) {
print "COND($1)\n" if ($dbg_values > 1);
$av_pending = 'E';
$type = 'N';

} elsif ($cur =~/^(case)/o) {
print "CASE($1)\n" if ($dbg_values > 1);
$av_pend_colon = 'C';
$type = 'N';

} elsif ($cur =~/^(return|else|goto|typeof|__typeof__)\b/o) {
print "KEYWORD($1)\n" if ($dbg_values > 1);
$type = 'N';

} elsif ($cur =~ /^(\()/o) {
print "PAREN('$1')\n" if ($dbg_values > 1);
push(@av_paren_type, $av_pending);
$av_pending = '_';
$type = 'N';

} elsif ($cur =~ /^(\))/o) {
my $new_type = pop(@av_paren_type);
if ($new_type ne '_') {
$type = $new_type;
print "PAREN('$1') -> $type\n"
if ($dbg_values > 1);
} else {
print "PAREN('$1')\n" if ($dbg_values > 1);
}

} elsif ($cur =~ /^($Ident)\s*\(/o) {
print "FUNC($1)\n" if ($dbg_values > 1);
$type = 'V';
$av_pending = 'V';

} elsif ($cur =~ /^($Ident\s*):(?:\s*\d+\s*(,|=|;))?/) {
if (defined $2 && $type eq 'C' || $type eq 'T') {
$av_pend_colon = 'B';
} elsif ($type eq 'E') {
$av_pend_colon = 'L';
}
print "IDENT_COLON($1,$type>$av_pend_colon)\n" if ($dbg_values > 1);
$type = 'V';

} elsif ($cur =~ /^($Ident|$Constant)/o) {
print "IDENT($1)\n" if ($dbg_values > 1);
$type = 'V';

} elsif ($cur =~ /^($Assignment)/o) {
print "ASSIGN($1)\n" if ($dbg_values > 1);
$type = 'N';

} elsif ($cur =~/^(;|{|})/) {
print "END($1)\n" if ($dbg_values > 1);
$type = 'E';
$av_pend_colon = 'O';

} elsif ($cur =~/^(,)/) {
print "COMMA($1)\n" if ($dbg_values > 1);
$type = 'C';

} elsif ($cur =~ /^(\?)/o) {
print "QUESTION($1)\n" if ($dbg_values > 1);
$type = 'N';

} elsif ($cur =~ /^(:)/o) {
print "COLON($1,$av_pend_colon)\n" if ($dbg_values > 1);

substr($var, length($res), 1, $av_pend_colon);
if ($av_pend_colon eq 'C' || $av_pend_colon eq 'L') {
$type = 'E';
} else {
$type = 'N';
}
$av_pend_colon = 'O';

} elsif ($cur =~ /^(\[)/o) {
print "CLOSE($1)\n" if ($dbg_values > 1);
$type = 'N';

} elsif ($cur =~ /^(-(?![->])|\+(?!\+)|\*|\&\&|\&)/o) {
my $variant;

print "OPV($1)\n" if ($dbg_values > 1);
if ($type eq 'V') {
$variant = 'B';
} else {
$variant = 'U';
}

substr($var, length($res), 1, $variant);
$type = 'N';

} elsif ($cur =~ /^($Operators)/o) {
print "OP($1)\n" if ($dbg_values > 1);
if ($1 ne '++' && $1 ne '--') {
$type = 'N';
}

} elsif ($cur =~ /(^.)/o) {
print "C($1)\n" if ($dbg_values > 1);
}
if (defined $1) {
$cur = substr($cur, length($1));
$res .= $type x length($1);
}
}

return ($res, $var);
}

sub possible {
it("\n", $output, -1);
\@\@ -\d+,\d+ \+\d+,\d+ \@\@/) {#new hunk
$range_last_linenr = $new_linenr;
fixup_current_range(\$line, $delta_offset, 0);
}

$type, $msg) = @_;

y ($string) = @_;

($string =~ /^($FuncArg|$balanced_parens)/) {
$pos += length($1) - 1;
} elsif (substr($line, $pos, 1) eq '(') {
$last_openparen = $pos;
} elsif (index($string, '(') == -1) {
last;
}
}

return length(expand_tabs(substr($line, 0, $last_openparen))) + 1;
}

sub process {
file = '';
comment.  Run
ne =~ /^(?:\+| |$)/) {
# Standardise the strings and chars within the input to
# simplify matching -- only bother with positive lines.
$line = sanitise_line($rawline);
}

 =~ /^diff --git.*?(\S+)$/) {
$realfile = $1;
$realfile =~ s@^([^/]*)/@@ if (!$file);
$in_commit_log = 0;
$found_file = 1;
} elsif ($line =~ /^\+\+\+\s+(\S+)/) {
$realfile = $1;
$realfile =~ s@^([^/]*)/@@ if (!$file);
$in_commit_log = 0;

$p1_prefix = $1;
if (!$file && $tree && $p1_prefix ne '' &&
        -e "$root/$p1_prefix") {
WARN("PATCH_PREFIX",
         "patch prefix '$p1_prefix' exists, appears to be a -p0 patch\n");
}

if ($realfile =~ m@^include/asm/@) {
ERROR("MODIFIED_INCLUDE_ASM",
          "do not modify files in include/asm, change architecture specific files in include/asm-<architecture>\n" . "$here$rawline\n");
}
$found_file = 1;
}

#make up the handle for any error we report on this line
ivers/staging/)@) {
|pl|awk|sh)$/) {
 . $herecurr) &&
DRESS",
      "The 'stable' address should be 'stable\@vger.kernel.org'\n" . $herecurr);
}

# Check for unwanted Gerrit info
if ($in_commit_log && $line =~ /^\s*change-id:/i) {
ERROR("GERRIT_CHANGE_ID",
      "Remove Gerrit Change-Id's before submitting upstream.\n" . $herecurr);
}

# Check if the commit log is in a possible stack dump
if ($in_commit_log && !$commit_log_possible_stack_dump &&
    ($line =~ /^\s*(?:WARNING:|BUG:)/ ||
     $line =~ /^\s*\[\s*\d+\.\d{6,6}\s*\]/ ||
# timestamp
     $line =~ /^\s*\[\<[0-9a-fA-F]{8,}\>\]/)) {
# stack dump address
$commit_log_possible_stack_dump = 1;
}

# Check for line lengths > 75 in commit log, warn once
if ($in_commit_log && !$commit_log_long_line &&
    length($line) > 75 &&
    !($line =~ /^\s*[a-zA-Z0-9_\/\.]+\s+\|\s+\d+/ ||
# file delta changes
      $line =~ /^\s*(?:[\w\.\-]+\/)++[\w\.\-]+:/ ||
# filename then :
      $line =~ /^\s*(?:Fixes:|Link:)/i ||
# A Fixes: or Link: line
      $commit_log_possible_stack_dump)) {
WARN("COMMIT_LOG_LONG_LINE",
     "Possible unwrapped commit description (prefer a maximum 75 chars per line)\n" . $herecurr);
$commit_log_long_line = 1;
}

# Reset possible stack dump if a blank line is found
if ($in_commit_log && $commit_log_possible_stack_dump &&
    $line =~ /^\s*$/) {
$commit_log_possible_stack_dump = 0;
}

# Check for git id commit length and improperly formed commit descriptions
if ($in_commit_log && !$commit_log_possible_stack_dump &&
    $line !~ /^\s*(?:Link|Patchwork|http|BugLink):/i &&
    ($line =~ /\bcommit\s+[0-9a-f]{5,}\b/i ||
     ($line =~ /\b[0-9a-f]{12,40}\b/i &&
      $line !~ /[\<\[][0-9a-f]{12,40}[\>\]]/i &&
      $line !~ /\bfixes:\s*[0-9a-f]{12,40}/i))) {
my $init_char = "c";
my $orig_commit = "";
my $short = 1;
my $long = 0;
my $case = 1;
my $space = 1;
my $hasdesc = 0;
my $hasparens = 0;
my $id = '0123456789ab';
my $orig_desc = "commit description";
my $description = "";

if ($line =~ /\b(c)ommit\s+([0-9a-f]{5,})\b/i) {
$init_char = $1;
$orig_commit = lc($2);
} elsif ($line =~ /\b([0-9a-f]{12,40})\b/i) {
$orig_commit = lc($1);
}

$short = 0 if ($line =~ /\bcommit\s+[0-9a-f]{12,40}/i);
$long = 1 if ($line =~ /\bcommit\s+[0-9a-f]{41,}/i);
$space = 0 if ($line =~ /\bcommit [0-9a-f]/i);
$case = 0 if ($line =~ /\b[Cc]ommit\s+[0-9a-f]{5,40}[^A-F]/);
if ($line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("([^"]+)"\)/i) {
$orig_desc = $1;
$hasparens = 1;
} elsif ($line =~ /\bcommit\s+[0-9a-f]{5,}\s*$/i &&
 defined $rawlines[$linenr] &&
 $rawlines[$linenr] =~ /^\s*\("([^"]+)"\)/) {
$orig_desc = $1;
$hasparens = 1;
} elsif ($line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("[^"]+$/i &&
 defined $rawlines[$linenr] &&
 $rawlines[$linenr] =~ /^\s*[^"]+"\)/) {
$line =~ /\bcommit\s+[0-9a-f]{5,}\s+\("([^"]+)$/i;
$orig_desc = $1;
$rawlines[$linenr] =~ /^\s*([^"]+)"\)/;
$orig_desc .= " " . $1;
$hasparens = 1;
}

($id, $description) = git_commit_info($orig_commit,
          $id, $orig_desc);

s to be corrupt (line wrapped?)\n" .
$herecurr) if (!$emitted_corrupt++);
}

# Check for absolute kernel paths.
if ($tree) {
while ($line =~ m{(?:^|\s)(/\S*)}g) {
my $file = $1;

if ($file =~ m{^(.*?)(?::\d+)+:?$} &&
    check_absolute_file($1, $herecurr)) {
#
} else {
check_absolute_file($file, $herecurr);
}
}
}

# UTF-8 regex found at http://www.w3.org/International/questions/qa-forms-utf-8.en.php
if (($realfile =~ /^$/ || $line =~ /^\+/) &&
    $rawline !~ m/^$UTF8*$/) {
my ($utf8_prefix) = ($rawline =~ /^($UTF8*)/);

my $blank = copy_spacing($rawline);
my $ptr = substr($blank, 0, length($utf8_prefix)) . "^";
my $hereptr = "$hereline$ptr\n";

CHK("INVALID_UTF8",
    "Invalid UTF-8, patch and commit message should be encoded in UTF-8\n" . $hereptr);
}

# Check if it's the start of a commit log
# (not a header line and we haven't seen the patch filename)
if ($in_header_lines && $realfile =~ /^$/ &&
    !($rawline =~ /^\s+\S/ ||
      $rawline =~ /^(commit\b|from\b|[\w-]+:).*$/i)) {
$in_header_lines = 0;
$in_commit_log = 1;
}

# Check if there is UTF-8 in a commit log when a mail header has explicitly
# declined it, i.e defined some charset where it is missing.
if ($in_header_lines &&
    $rawline =~ /^Content-Type:.+charset="(.+)".*$/ &&
    $1 !~ /utf-8/i) {
$non_utf8_charset = 1;
}

if ($in_commit_log && $non_utf8_charset && $realfile =~ /^$/ &&
    $rawline =~ /$NON_ASCII_UTF8/) {
WARN("UTF8_BEFORE_PATCH",
    "8-bit UTF-8 used in possible commit log\n" . $herecurr);
}

# Check for various typo / spelling mistakes
if (defined($misspellings) &&
    ($in_commit_log || $line =~ /^(?:\+|Subject:)/i)) {
while ($rawline =~ /(?:^|[^a-z@])($misspellings)(?:\b|$|[^a-z@])/gi) {
my $typo = $1;
my $typo_fix = $spelling_fix{lc($typo)};
$typo_fix = ucfirst($typo_fix) if ($typo =~ /^[A-Z]/);
$typo_fix = uc($typo_fix) if ($typo =~ /^[A-Z]+$/);
my $msg_type = \&WARN;
$msg_type = \&CHK if ($file);
if (&{$msg_type}("TYPO_SPELLING",
 "'$typo' may be misspelled - perhaps '$typo_fix'?\n" . $herecurr) &&
    $fix) {
$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;
}
}
}

# ignore non-hunk lines and lines being removed
next if (!$hunk_line || $line =~ /^-/);

#trailing whitespace
if ($line =~ /^\+.*\015/) {
my $herevet = "$here\n" . cat_vet($rawline) . "\n";
if (ERROR("DOS_LINE_ENDINGS",
  "DOS line endings\n" . $herevet) &&
    $fix) {
$fixed[$fixlinenr] =~ s/[\s\015]+$//;
}
} elsif ($rawline =~ /^\+.*\S\s+$/ || $rawline =~ /^\+\s+$/) {
my $herevet = "$here\n" . cat_vet($rawline) . "\n";
if (ERROR("TRAILING_WHITESPACE",
  "trailing whitespace\n" . $herevet) &&
    $fix) {
$fixed[$fixlinenr] =~ s/\s+$//;
}

$rpt_cleaners = 1;
}

# Check for FSF mailing addresses.
if ($rawline =~ /\bwrite to the Free/i ||
    $rawline =~ /\b59\s+Temple\s+Pl/i ||
    $rawline =~ /\b51\s+Franklin\s+St/i) {
my $herevet = "$here\n" . cat_vet($rawline) . "\n";
my $msg_type = \&ERROR;
$msg_type = \&CHK if ($file);
&{$msg_type}("FSF_MAILING_ADDRESS",
     "Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\n" . $herevet)
}

# check for Kconfig help text having a real description
# Only applies when adding the entry originally, after that we do not have
# sufficient context to determine whether it is indeed long enough.
if ($realfile =~ /Kconfig/ &&
    $line =~ /^\+\s*config\s+/) {
my $length = 0;
my $cnt = $realcnt;
my $ln = $linenr + 1;
my $f;
my $is_start = 0;
my $is_end = 0;
for (; $cnt > 0 && defined $lines[$ln - 1]; $ln++) {
$f = $lines[$ln - 1];
$cnt-- if ($lines[$ln - 1] !~ /^-/);
$is_end = $lines[$ln - 1] =~ /^\+/;

next if ($f =~ /^-/);
last if (!$file && $f =~ /^\@\@/);

if ($lines[$ln - 1] =~ /^\+\s*(?:bool|tristate)\s*\"/) {
$is_start = 1;
} elsif ($lines[$ln - 1] =~ /^\+\s*(?:---)?help(?:---)?$/) {
$length = -1;
}

$f =~ s/^.//;
$f =~ s/#.*//;
$f =~ s/^\s+//;
next if ($f =~ /^$/);
if ($f =~ /^\s*config\s/) {
$is_end = 1;
last;
}
$length++;
}
if ($is_start && $is_end && $length < $min_conf_desc_length) {
WARN("CONFIG_DESCRIPTION",
     "please write a paragraph that describes the config symbol fully\n" . $herecurr);
}
#print "is_start<$is_start> is_end<$is_end> length<$length>\n";
}

# discourage the addition of CONFIG_EXPERIMENTAL in Kconfig.
if ($realfile =~ /Kconfig/ &&
    $line =~ /.\s*depends on\s+.*\bEXPERIMENTAL\b/) {
WARN("CONFIG_EXPERIMENTAL",
     "Use of CONFIG_EXPERIMENTAL is deprecated. For alternatives, see https://lkml.org/lkml/2012/10/23/580\n");
}

# discourage the use of boolean for type definition attributes of Kconfig options
if ($realfile =~ /Kconfig/ &&
    $line =~ /^\+\s*\bboolean\b/) {
WARN("CONFIG_TYPE_BOOLEAN",
     "Use of boolean is deprecated, please use bool instead.\n" . $herecurr);
}

if (($realfile =~ /Makefile.*/ || $realfile =~ /Kbuild.*/) &&
    ($line =~ /\+(EXTRA_[A-Z]+FLAGS).*/)) {
my $flag = $1;
my $replacement = {
'EXTRA_AFLAGS' =>   'asflags-y',
'EXTRA_CFLAGS' =>   'ccflags-y',
'EXTRA_CPPFLAGS' => 'cppflags-y',
'EXTRA_LDFLAGS' =>  'ldflags-y',
};

WARN("DEPRECATED_VARIABLE",
     "Use of $flag is deprecated, please use \`$replacement->{$flag} instead.\n" . $herecurr) if ($replacement->{$flag});
}

# check for DT compatible documentation
if (defined $root &&
(($realfile =~ /\.dtsi?$/ && $line =~ /^\+\s*compatible\s*=\s*\"/) ||
 ($realfile =~ /\.[ch]$/ && $line =~ /^\+.*\.compatible\s*=\s*\"/))) {

my @compats = $rawline =~ /\"([a-zA-Z0-9\-\,\.\+_]+)\"/g;

my $dt_path = $root . "/Documentation/devicetree/bindings/";
my $vp_file = $dt_path . "vendor-prefixes.txt";

foreach my $compat (@compats) {
my $compat2 = $compat;
$compat2 =~ s/\,[a-zA-Z0-9]*\-/\,<\.\*>\-/;
my $compat3 = $compat;
$compat3 =~ s/\,([a-z]*)[0-9]*\-/\,$1<\.\*>\-/;
`grep -Erq "$compat|$compat2|$compat3" $dt_path`;
if ( $? >> 8 ) {
WARN("UNDOCUMENTED_DT_STRING",
         "DT compatible string \"$compat\" appears un-documented -- check $dt_path\n" . $herecurr);
}

next if $compat !~ /^([a-zA-Z0-9\-]+)\,/;
my $vendor = $1;
`grep -Eq "^$vendor\\b" $vp_file`;
if ( $? >> 8 ) {
WARN("UNDOCUMENTED_DT_STRING",
         "DT compatible string vendor \"$vendor\" appears un-documented -- check $vp_file\n" . $herecurr);
}
}
}

# check we are in a valid source file if not then ignore this hunk
nes that are a single string
#
# There are 3 different line length message types:
# LONG_LINE_COMMENTa comment starts before but extends beyond $max_linelength
# LONG_LINE_STRINGa string starts before but extends beyond $max_line_length
# LONG_LINEall other lines longer than $max_line_length
#
# if LONG_LINE is ignored, the other 2 types are also ignored
#

_type = "";

;
n matches previous line
nction pointer declarations like "(*foo)(int) = bar;"
#   structure definitions like "(struct foo) { 0 };"
#   multiline macros that define functions
#   known attributes or the __attribute__ keyword
 /*

=~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||
# known declaration macros
     $prevline =~ /^\+\s+$declaration_macros/) &&
# for "else if" which can look like "$Ident $Ident"
    !($prevline =~ /^\+\s+$c90_Keywords\b/ ||
# other possible extensions of declaration lines
      $prevline =~ /(?:$Compare|$Assignment|$Operators)\s*$/ ||
# not starting a section or a macro "\" extended line
      $prevline =~ /(?:\{\s*|\\)$/) &&
# looks like a declaration
    !($sline =~ /^\+\s+$Declare\s*$Ident\s*[=,;:\[]/ ||
# function pointer declarations
      $sline =~ /^\+\s+$Declare\s*\(\s*\*\s*$Ident\s*\)\s*[=,;:\[\(]/ ||
# foo bar; where foo is some local typedef or #define
      $sline =~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||
# known declaration macros
      $sline =~ /^\+\s+$declaration_macros/ ||
# start of struct or union or enum
      $sline =~ /^\+\s+(?:union|struct|enum|typedef)\b/ ||
# start or end of block or continuation of declaration
      $sline =~ /^\+\s+(?:$|[\{\}\.\#\"\?\:\(\[])/ ||
# bitfield continuation
      $sline =~ /^\+\s+$Ident\s*:\s*\d+\s*[,;]/ ||
# other possible extensions of declaration lines
      $sline =~ /^\+\s+\(?\s*(?:$Compare|$Assignment|$Operators)/) &&
# indentation of previous and current line are the same
    (($prevline =~ /\+(\s+)\S/) && $sline =~ /^\+$1\S/)) {
if (WARN("LINE_SPACING",
 "Missing a blank line after declarations\n" . $hereprev) &&
        $fix) {
fix_insert_line($fixlinenr, "\+");
}
}

# check for spaces at the beginning of a line.
# Exceptions:
#  1) within comments
#  2) indented preprocessor commands
#  3) hanging labels
gnore this hunk
age the addition of CONFIG_EXPERIMENTAL in #if(def).
$1 is unnecessary\n" . $herecurr);
}

# Check for potential 'bare' types
my ($stat, $cond, $line_nr_next, $remain_next, $off_next,
    $realline_next);
#print "LINE<$line>\n";
if ($linenr >= $suppress_statement &&
    $realcnt && $sline =~ /.\s*\S/) {
($stat, $cond, $line_nr_next, $remain_next, $off_next) =
$//s;

rage|$Inline)\s*)*\s*$Type\s*(?:\b$Ident|\(\*\s*$Ident\))\s*)\(/s) {
e indent\n$hereline$err");
}
}

# if/while/etc brace do not go on next line, unless defining a do while loop,
# or if that brace on the next line is for something else
#if ($line =~ /(.*)\b((?:if|while|for|switch|(?:[a-z_]+|)for_each[a-z_]+)\s*\(|do\b|else\b)/ && $line !~ /^.\s*\#/) {
 /^-/);
f ($line =~ /\b(?:(?:if|while|for|(?:[a-z_]+|)for_each[a-z_]+)\s*\(|do\b)/ && $line !~ /^.\s*#/ && $line !~ /\}\s*while\s*/) {
($stat, $cond, $line_nr_next, $remain_next, $off_next) =
ctx_statement_block($linenr, $realcnt, 0)
if (!defined $stat);
my ($s, $c) = ($stat, $cond);

substr($s, 0, length($c), '');

# remove inline comments
$s =~ s/$;/ /g;
$c =~ s/$;/ /g;

# Find out how long the conditional actually is.
my @newlines = ($c =~ /\n/gs);
my $cond_lines = 1 + $#newlines;

# Make sure we remove the line prefixes as we have
# none on the first line, and are going to readd them
# where necessary.
$s =~ s/\n./\n/gs;
while ($s =~ /\n\s+\\\n/) {
$cond_lines += $s =~ s/\n\s+\\\n/\n/g;
}

# We want to check the first line inside the block
# starting at the end of the conditional, so remove:
#  1) any blank line termination
#  2) any opening brace { on end of the line
#  3) any do (...) {
my $continuation = 0;
my $check = 0;
$s =~ s/^.*\bdo\b//;
$s =~ s/^\s*{//;
if ($s =~ s/^\s*\\//) {
$continuation = 1;
}
if ($s =~ s/^\s*?\n//) {
$check = 1;
$cond_lines++;
}

# Also ignore a loop construct at the end of a
# preprocessor statement.
if (($prevline =~ /^.\s*#\s*define\s/ ||
        $prevline =~ /\\\s*$/) && $continuation == 0) {
$check = 0;
}

my $cond_ptr = -1;
$continuation = 0;
while ($cond_ptr != $cond_lines) {
$cond_ptr = $cond_lines;

# If we see an #else/#elif then the code
# is not linear.
if ($s =~ /^\s*\#\s*(?:else|elif)/) {
$check = 0;
}

# Ignore:
#  1) blank lines, they should be at 0,
#  2) preprocessor lines, and
#  3) labels.
if ($continuation ||
    $s =~ /^\s*?\n/ ||
    $s =~ /^\s*#\s*?/ ||
    $s =~ /^\s*$Ident\s*:/) {
$continuation = ($s =~ /^.*?\\\n/) ? 1 : 0;
if ($s =~ s/^.*?\n//) {
$cond_lines++;
}
}
}

my (undef, $sindent) = line_stats("+" . $s);
my $stat_real = raw_line($linenr, $cond_lines);

# Check if either of these lines are modified, else
# this is not this patch's fault.
if (!defined($stat_real) ||
        $stat !~ /^\+/ && $stat_real !~ /^\+/) {
$check = 0;
}
if (defined($stat_real) && $cond_lines > 1) {
$stat_real = "[...]\n$stat_real";
}

#print "line<$line> prevline<$prevline> indent<$indent> sindent<$sindent> check<$check> continuation<$continuation> s<$s> cond_lines<$cond_lines> stat_real<$stat_real> stat<$stat>\n";

if ($check && $s ne '' &&
        (($sindent % 8) != 0 ||
	     ($sindent < $indent) ||
	     ($sindent > $indent + 8))) {
WARN("SUSPECT_CODE_INDENT",
         "suspect code indent for conditional statements ($indent, $sindent)\n" . $herecurr . "$stat_real\n");
}
}

ues) {
);

x) {
$Ident\(\Q$name\E\)|
^.DECLARE_$Ident\(\Q$name\E\)|
^.LIST_HEAD\(\Q$name\E\)|
^.(?:$Storage\s+)?$Type\s*\(\s*\*\s*\Q$name\E\s*\)\s*\(|
\b\Q$name\E(?:\s+$Attribute)*\s*(?:;|=|\[|\()
    )/x) {
#print "FOO A<$lines[$realline_next - 1]> stat<$stat> name<$name>\n";
 globals to $1\n" . $herecurr) &&
    $fix) {
$fixed[$fixlinenr] =~ s/(^.$Type\s*$Ident(?:\s+$Modifier)*)\s*=\s*$zero_initializer\s*;/$1;/;
}
}
# check for static initialisers.
if ($line =~ /^\+.*\bstatic\s.*=\s*($zero_initializer)\s*;/) {
if (ERROR("INITIALISED_STATIC",
  "do not initialise statics to $1\n" .
      $herecurr) &&
    $fix) {
$fixed[$fixlinenr] =~ s/(\bstatic\s.*?)\s*=\s*$zero_initializer\s*;/$1;/;
}
}

# check for misordered declarations of char/short/int/long with signed/unsigned
while ($sline =~ m{(\b$TypeMisordered\b)}g) {
my $tmp = trim($1);
WARN("MISORDERED_TYPE",
     "type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\n" . $herecurr);
}

# check for static const char * arrays.
if ($line =~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*=\s*/) {
WARN("STATIC_CONST_CHAR_ARRAY",
     "static const char * array should probably be static const char * const\n" .
$herecurr);
               }

# check for static char foo[] = "bar" declarations.
if ($line =~ /\bstatic\s+char\s+(\w+)\s*\[\s*\]\s*=\s*"/) {
WARN("STATIC_CONST_CHAR_ARRAY",
         "static char array declaration should probably be static const char\n" .
    $herecurr);
               }

# check for const <foo> const where <foo> is not a pointer or array type
erecurr);
               }

# check for sizeof(foo)/sizeof(foo[0]) that could be ARRAY_SIZE(foo)
CI_DEVICE_TABLE\n" . $herecurr) &&
    $fix) {
$fixed[$fixlinenr] =~ s/\b(?:static\s+|)DEFINE_PCI_DEVICE_TABLE\s*\(\s*(\w+)\s*\)\s*=\s*/static const struct pci_device_id $1\[\] = /;
}
}

# check for new typedefs, only function parameters and sparse annotations
# make sense.
# if ($line =~ /\btypedef\s/ &&
#     $line !~ /\btypedef\s+$Type\s*\(\s*\*?$Ident\s*\)\s*\(/ &&
#     $line !~ /\btypedef\s+$Type\s+$Ident\s*\(/ &&
#     $line !~ /\b$typeTypedefs\b/ &&
#     $line !~ /\b__bitwise(?:__|)\b/) {
# WARN("NEW_TYPEDEFS",
#      "do not add new typedefs\n" . $herecurr);
# }

# * goes on variable not on type
# (char*[ const])
while ($line =~ m{(\($NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)\))}g) {
#print "AA<$1>\n";
my ($ident, $from, $to) = ($1, $2, $2);

# Should start with a space.
$to =~ s/^(\S)/ $1/;
# Should not end with a space.
$to =~ s/\s+$//;
# '*'s should not have spaces between.
while ($to =~ s/\*\s+\*/\*\*/) {
}

##print "1: from<$from> to<$to> ident<$ident>\n";
if ($from ne $to) {
if (ERROR("POINTER_LOCATION",
  "\"(foo$from)\" should be \"(foo$to)\"\n" .  $herecurr) &&
    $fix) {
my $sub_from = $ident;
my $sub_to = $ident;
$sub_to =~ s/\Q$from\E/$to/;
$fixed[$fixlinenr] =~
    s@\Q$sub_from\E@$sub_to@;
}
}
}
while ($line =~ m{(\b$NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)($Ident))}g) {
#print "BB<$1>\n";
my ($match, $from, $to, $ident) = ($1, $2, $2, $3);

# Should start with a space.
$to =~ s/^(\S)/ $1/;
# Should not end with a space.
$to =~ s/\s+$//;
# '*'s should not have spaces between.
while ($to =~ s/\*\s+\*/\*\*/) {
}
# Modifiers should have spaces.
$to =~ s/(\b$Modifier$)/$1 /;

##print "2: from<$from> to<$to> ident<$ident>\n";
if ($from ne $to && $ident !~ /^$Modifier$/) {
if (ERROR("POINTER_LOCATION",
  "\"foo${from}bar\" should be \"foo${to}bar\"\n" .  $herecurr) &&
    $fix) {

my $sub_from = $match;
my $sub_to = $match;
$sub_to =~ s/\Q$from\E/$to/;
$fixed[$fixlinenr] =~
    s@\Q$sub_from\E@$sub_to@;
}
}
}

# avoid BUG() or BUG_ON()
if ($line =~ /\b(?:BUG|BUG_ON)\b/) {
my $msg_type = \&WARN;
$msg_type = \&CHK if ($file);
&{$msg_type}("AVOID_BUG",
     "Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()\n" . $herecurr);
}

# avoid LINUX_VERSION_CODE
if ($line =~ /\bLINUX_VERSION_CODE\b/) {
WARN("LINUX_VERSION_CODE",
     "LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\n" . $herecurr);
}

# check for uses of printk_ratelimit
if ($line =~ /\bprintk_ratelimit\s*\(/) {
WARN("PRINTK_RATELIMITED",
     "Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\n" . $herecurr);
}

# printk should use KERN_* levels.  Note that follow on printk's on the
# same line do not need a level, so we use the current block context
# to try and find and validate the current printk.  In summary the current
# printk includes all preceding printk's which have no newline on the end.
# we assume the first bad printk is the one to report.
if ($line =~ /\bprintk\((?!KERN_)\s*"/) {
printk(KERN_$orig ...\n" . $herecurr);
}

if ($line =~ /\bpr_warning\s*\(/) {
if (WARN("PREFER_PR_LEVEL",
 "Prefer pr_warn(... to pr_warning(...\n" . $herecurr) &&
    $fix) {
$fixed[$fixlinenr] =~
    s/\bpr_warning\b/pr_warn/;
}
}

if ($line =~ /\bdev_printk\s*\(\s*KERN_([A-Z]+)/) {
my $orig = $1;
my $level = lc($orig);
$level = "warn" if ($level eq "warning");
$level = "dbg" if ($level eq "debug");
WARN("PREFER_DEV_LEVEL",
     "Prefer dev_$level(... to dev_printk(KERN_$orig, ...\n" . $herecurr);
}

# ENOSYS means "bad syscall nr" and nothing else.  This will have a small
# number of false positives, but assembly files are not checked, so at
# least the arch entry code will not trigger this warning.
if ($line =~ /\bENOSYS\b/) {
WARN("ENOSYS",
     "ENOSYS means 'invalid syscall nr' and nothing else\n" . $herecurr);
}

# function brace can't be on same line, except for #defines of do while,
# or if closed on same line
if (($line=~/$Type\s*$Ident\(.*\).*\s*{/) and
    !($line=~/\#\s*define.*do\s\{/) and !($line=~/}/)) {
if (ERROR("OPEN_BRACE",
  "open brace '{' following function declarations go on the next line\n" . $herecurr) &&
    $fix) {
fix_delete_line($fixlinenr, $rawline);
my $fixed_line = $rawline;
$fixed_line =~ /(^..*$Type\s*$Ident\(.*\)\s*){(.*)$/;
my $line1 = $1;
my $line2 = $2;
fix_insert_line($fixlinenr, ltrim($line1));
fix_insert_line($fixlinenr, "\+{");
if ($line2 !~ /^\s*$/) {
fix_insert_line($fixlinenr, "\+\t" . trim($line2));
}
}
}

# check number of functions
# and number of lines per function
if ($line =~ /.*}.*/) {
$inscope--;
}

if ($inscope >= 1) {
$funclines++;
if ($funclines > $max_func_length) {
WARN("FUNCTIONS",
  "More than $max_func_length lines in a function\n");
}
}

if ($line =~ /.*{.*/) {
$inscope++;
if ($prevline =~ /^(.(?:typedef\s*)?(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*(?:\b$Ident|\(\*\s*$Ident\))\s*)\(/s && $inscope == 1) {
$nbfunc++;
$funclines = 0;
if ($nbfunc > $max_funcs) {
my $tmpline = $realline - 1;
if ($showfile) {
$prefix = "$realfile:$tmpline: ";
} elsif ($emacs) {
if ($file) {
$prefix = "$realfile:$tmpline: ";
} else {
$prefix = "$realfile:$tmpline: ";
}
}
ERROR("FUNCTIONS",
  "More than $max_funcs functions in the file\n");
}
}
}

# open braces for enum, union and struct go on the same line.
# if ($line =~ /^.\s*{/ &&
#     $prevline =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*$/) {
# if (ERROR("OPEN_BRACE",
#   "open brace '{' following $1 go on the same line\n" . $hereprev) &&
#     $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
# fix_delete_line($fixlinenr - 1, $prevrawline);
# fix_delete_line($fixlinenr, $rawline);
# my $fixedline = rtrim($prevrawline) . " {";
# fix_insert_line($fixlinenr, $fixedline);
# $fixedline = $rawline;
# $fixedline =~ s/^(.\s*){\s*/$1\t/;
# if ($fixedline !~ /^\+\s*$/) {
# fix_insert_line($fixlinenr, $fixedline);
# }
# }
# }
#
if ($realfile =~ /\.c$/ &&
    $line =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*.*/) {
WARN("STRUCT_DEF",
"$1 definition should be avoided in .c files\n");
}

if ($line =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*{/) {
if (ERROR("OPEN_BRACE",
  "open brace '{' following $1 go on the next line\n" . $hereprev) &&
    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {
fix_delete_line($fixlinenr - 1, $prevrawline);
fix_delete_line($fixlinenr, $rawline);
my $fixedline = rtrim($prevrawline) . " {";
fix_insert_line($fixlinenr, $fixedline);
$fixedline = $rawline;
$fixedline =~ s/^(.\s*){\s*/$1\t/;
if ($fixedline !~ /^\+\s*$/) {
fix_insert_line($fixlinenr, $fixedline);
}
}
}

# missing space after union, struct or enum definition
# if ($line =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident){1,2}[=\{]/) {
# if (WARN("SPACING",
#  "missing space after $1 definition\n" . $herecurr) &&
#     $fix) {
# $fixed[$fixlinenr] =~
#     s/^(.\s*(?:typedef\s+)?(?:enum|union|struct)(?:\s+$Ident){1,2})([=\{])/$1 $2/;
# }
# }

# Function pointer declarations
# check spacing between type, funcptr, and args
# canonical declaration is "type (*funcptr)(args...)"
if ($line =~ /^.\s*($Declare)\((\s*)\*(\s*)($Ident)(\s*)\)(\s*)\(/) {
my $declare = $1;
my $pre_pointer_space = $2;
my $post_pointer_space = $3;
my $funcname = $4;
my $post_funcname_space = $5;
my $pre_args_space = $6;

# the $Declare variable will capture all spaces after the type
# so check it for a missing trailing missing space but pointer return types
# don't need a space so don't warn for those.
my $post_declare_space = "";
if ($declare =~ /(\s+)$/) {
$post_declare_space = $1;
$declare = rtrim($declare);
}
if ($declare !~ /\*$/ && $post_declare_space =~ /^$/) {
WARN("SPACING",
     "missing space after return type\n" . $herecurr);
$post_declare_space = " ";
}

# unnecessary space "type  (*funcptr)(args...)"
# This test is not currently implemented because these declarations are
# equivalent to
#int  foo(int bar, ...)
# and this is form shouldn't/doesn't generate a checkpatch warning.
#
#elsif ($declare =~ /\s{2,}$/) {
#WARN("SPACING",
#     "Multiple spaces after return type\n" . $herecurr);
#}

# unnecessary space "type ( *funcptr)(args...)"
if (defined $pre_pointer_space &&
    $pre_pointer_space =~ /^\s/) {
WARN("SPACING",
     "Unnecessary space after function pointer open parenthesis\n" . $herecurr);
}

# unnecessary space "type (* funcptr)(args...)"
if (defined $post_pointer_space &&
    $post_pointer_space =~ /^\s/) {
WARN("SPACING",
     "Unnecessary space before function pointer name\n" . $herecurr);
}

# unnecessary space "type (*funcptr )(args...)"
if (defined $post_funcname_space &&
    $post_funcname_space =~ /^\s/) {
WARN("SPACING",
     "Unnecessary space after function pointer name\n" . $herecurr);
}

# unnecessary space "type (*funcptr) (args...)"
if (defined $pre_args_space &&
    $pre_args_space =~ /^\s/) {
WARN("SPACING",
     "Unnecessary space before function pointer arguments\n" . $herecurr);
}

if (show_type("SPACING") && $fix) {
$fixed[$fixlinenr] =~
    s/^(.\s*)$Declare\s*\(\s*\*\s*$Ident\s*\)\s*\(/$1 . $declare . $post_declare_space . '(*' . $funcname . ')('/ex;
}
}

# check for spacing round square brackets; allowed:
#  1. with a type on the left -- int [] a;
#  2. at the beginning of a line for slice initialisers -- [0...10] = 5,
#  3. inside a curly brace -- = { [0...10] = 5 }
while ($line =~ /(.*?\s)\[/g) {
my ($where, $prefix) = ($-[1], $1);
if ($prefix !~ /$Type\s+$/ &&
    ($where != 0 || $prefix !~ /^.\s+$/) &&
    $prefix !~ /[{,]\s+$/) {
if (ERROR("BRACKET_SPACE",
  "space prohibited before open square bracket '['\n" . $herecurr) &&
    $fix) {
    $fixed[$fixlinenr] =~
s/^(\+.*?)\s+\[/$1\[/;
}
}
}

# check for spaces between functions and their parentheses.
while ($line =~ /($Ident)\s+\(/g) {
my $name = $1;
my $ctx_before = substr($line, 0, $-[1]);
my $ctx = "$ctx_before$name";

# Ignore those directives where spaces _are_ permitted.
if ($name =~ /^(?:
if|for|while|switch|return|case|
volatile|__volatile__|
__attribute__|format|__extension__|
asm|__asm__)$/x)
{
# cpp #define statements have non-optional spaces, ie
# if there is a space between the name and the open
# parenthesis it is simply not a parameter group.
} elsif ($ctx_before =~ /^.\s*\#\s*define\s*$/) {

# cpp #elif statement condition may start with a (
} elsif ($ctx =~ /^.\s*\#\s*elif\s*$/) {

# If this whole things ends with a type its most
# likely a typedef for a function.
} elsif ($ctx =~ /$Type$/) {

} else {
if (WARN("SPACING",
     "space prohibited between function name and open parenthesis '('\n" . $herecurr) &&
     $fix) {
$fixed[$fixlinenr] =~
    s/\b$name\s+\(/$name\(/;
}
}
}

# Check operator spacing.
if (!($line=~/\#\s*include/)) {
my $fixed_line = "";
my $line_fixed = 0;

my $ops = qr{
<<=|>>=|<=|>=|==|!=|
\+=|-=|\*=|\/=|%=|\^=|\|=|&=|
=>|->|<<|>>|<|>|=|!|~|
&&|\|\||,|\^|\+\+|--|&|\||\+|-|\*|\/|%|
\?:|\?|:
}x;
my @elements = split(/($ops|;)/, $opline);

##print("element count: <" . $#elements . ">\n");
##foreach my $el (@elements) {
##print("el: <$el>\n");
##}

    my @fix_elements = ();
    my $off = 0;

    foreach my $el (@elements) {
push(@fix_elements, substr($rawline, $off, length($el)));
$off += length($el);
}

    $off = 0;

    my $blank = copy_spacing($opline);
    my $last_after = -1;

    for (my $n = 0; $n < $#elements; $n += 2) {

my $good = $fix_elements[$n] . $fix_elements[$n + 1];

##print("n: <$n> good: <$good>\n");

$off += length($elements[$n]);

# Pick up the preceding and succeeding characters.
my $ca = substr($opline, 0, $off);
my $cc = '';
if (length($opline) >= ($off + length($elements[$n + 1]))) {
$cc = substr($opline, $off + length($elements[$n + 1]));
}
my $cb = "$ca$;$cc";

my $a = '';
$a = 'V' if ($elements[$n] ne '');
$a = 'W' if ($elements[$n] =~ /\s$/);
$a = 'C' if ($elements[$n] =~ /$;$/);
$a = 'B' if ($elements[$n] =~ /(\[|\()$/);
$a = 'O' if ($elements[$n] eq '');
$a = 'E' if ($ca =~ /^\s*$/);

my $op = $elements[$n + 1];

my $c = '';
if (defined $elements[$n + 2]) {
$c = 'V' if ($elements[$n + 2] ne '');
$c = 'W' if ($elements[$n + 2] =~ /^\s/);
$c = 'C' if ($elements[$n + 2] =~ /^$;/);
$c = 'B' if ($elements[$n + 2] =~ /^(\)|\]|;)/);
$c = 'O' if ($elements[$n + 2] eq '');
$c = 'E' if ($elements[$n + 2] =~ /^\s*\\$/);
} else {
$c = 'E';
}

my $ctx = "${a}x${c}";

my $at = "(ctx:$ctx)";

my $ptr = substr($blank, 0, $off) . "^";
my $hereptr = "$hereline$ptr\n";

# Pull out the value of this operator.
my $op_type = substr($curr_values, $off + 1, 1);

# Get the full operator variant.
my $opv = $op . substr($curr_vars, $off, 1);

# Ignore operators passed as parameters.
if ($op_type ne 'V' &&
        $ca =~ /\s$/ && $cc =~ /^\s*[,\)]/) {

## Ignore comments
#} elsif ($op =~ /^$;+$/) {

# ; should have either the end of line or a space or \ after it
} elsif ($op eq ';') {
if ($ctx !~ /.x[WEBC]/ &&
        $cc !~ /^\\/ && $cc !~ /^;/) {
if (ERROR("SPACING",
      "space required after that '$op' $at\n" . $hereptr)) {
$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . " ";
$line_fixed = 1;
}
}

# // is a comment
} elsif ($op eq '//') {

#   :   when part of a bitfield
} elsif ($opv eq ':B') {
# skip the bitfield test for now

# No spaces for:
#   ->
} elsif ($op eq '->') {
if ($ctx =~ /Wx.|.xW/) {
if (ERROR("SPACING",
      "spaces prohibited around that '$op' $at\n" . $hereptr)) {
$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);
if (defined $fix_elements[$n + 2]) {
$fix_elements[$n + 2] =~ s/^\s+//;
}
$line_fixed = 1;
}
}

# , must not have a space before and must have a space on the right.
} elsif ($op eq ',') {
my $rtrim_before = 0;
my $space_after = 0;
if ($ctx =~ /Wx./) {
if (ERROR("SPACING",
      "space prohibited before that '$op' $at\n" . $hereptr)) {
$line_fixed = 1;
$rtrim_before = 1;
}
}
if ($ctx !~ /.x[WEC]/ && $cc !~ /^}/) {
if (ERROR("SPACING",
      "space required after that '$op' $at\n" . $hereptr)) {
$line_fixed = 1;
$last_after = $n;
$space_after = 1;
}
}
if ($rtrim_before || $space_after) {
if ($rtrim_before) {
$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);
} else {
$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);
}
if ($space_after) {
$good .= " ";
}
}

    # '*' as part of a type definition -- reported already.
    } elsif ($opv eq '*_') {
#warn "'*' is part of type\n";

# unary operators should have a space before and
# none after.  May be left adjacent to another
# unary operator, or a cast
} elsif ($op eq '!' || $op eq '~' ||
     $opv eq '*U' || $opv eq '-U' || $opv eq '+U' ||
     $opv eq '&U' || $opv eq '&&U') {
if ($ctx !~ /[WEBC]x./ && $ca !~ /(?:\)|!|~|\*|-|\+|\&|\||\+\+|\-\-|\{)$/) {
if (ERROR("SPACING",
  "space required before that '$op' $at\n" . $hereptr)) {
if ($n != $last_after + 2) {
$good = $fix_elements[$n] . " " . ltrim($fix_elements[$n + 1]);
$line_fixed = 1;
}
}
}
if ($op eq '*' && $cc =~/\s*$Modifier\b/) {
# A unary '*' may be const

} elsif ($ctx =~ /.xW/) {
if (ERROR("SPACING",
      "space prohibited after that '$op' $at\n" . $hereptr)) {
$good = $fix_elements[$n] . rtrim($fix_elements[$n + 1]);
if (defined $fix_elements[$n + 2]) {
$fix_elements[$n + 2] =~ s/^\s+//;
}
$line_fixed = 1;
}
}

# unary ++ and unary -- are allowed no space on one side.
} elsif ($op eq '++' or $op eq '--') {
if ($ctx !~ /[WEOBC]x[^W]/ && $ctx !~ /[^W]x[WOBEC]/) {
if (ERROR("SPACING",
      "space required one side of that '$op' $at\n" . $hereptr)) {
$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . " ";
$line_fixed = 1;
}
}
if ($ctx =~ /Wx[BE]/ ||
        ($ctx =~ /Wx./ && $cc =~ /^;/)) {
if (ERROR("SPACING",
      "space prohibited before that '$op' $at\n" . $hereptr)) {
$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);
$line_fixed = 1;
}
}
if ($ctx =~ /ExW/) {
if (ERROR("SPACING",
      "space prohibited after that '$op' $at\n" . $hereptr)) {
$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);
if (defined $fix_elements[$n + 2]) {
$fix_elements[$n + 2] =~ s/^\s+//;
}
$line_fixed = 1;
}
}

# << and >> may either have or not have spaces both sides
} elsif ($op eq '<<' or $op eq '>>' or
     $op eq '&' or $op eq '^' or $op eq '|' or
     $op eq '+' or $op eq '-' or
     $op eq '*' or $op eq '/' or
     $op eq '%')
}